[{"D:\\Code\\Projects\\maze-algorithms\\src\\index.js":"1","D:\\Code\\Projects\\maze-algorithms\\src\\App.js":"2","D:\\Code\\Projects\\maze-algorithms\\src\\reportWebVitals.js":"3","D:\\Code\\Projects\\maze-algorithms\\src\\components\\AppCanvas\\index.js":"4","D:\\Code\\Projects\\maze-algorithms\\src\\components\\Controls\\index.js":"5","D:\\Code\\Projects\\maze-algorithms\\src\\utils\\SquareGrid.js":"6","D:\\Code\\Projects\\maze-algorithms\\src\\utils\\GridPoint.js":"7","D:\\Code\\Projects\\maze-algorithms\\src\\utils\\HexGrid.js":"8","D:\\Code\\Projects\\maze-algorithms\\src\\components\\Controls\\Slider.js":"9","D:\\Code\\Projects\\maze-algorithms\\src\\utils\\MazeGenerator.js":"10"},{"size":500,"mtime":499162500000,"results":"11","hashOfConfig":"12"},{"size":1839,"mtime":1607832174231,"results":"13","hashOfConfig":"12"},{"size":362,"mtime":499162500000,"results":"14","hashOfConfig":"12"},{"size":4686,"mtime":1607892257013,"results":"15","hashOfConfig":"12"},{"size":4504,"mtime":1607834773302,"results":"16","hashOfConfig":"12"},{"size":1099,"mtime":1607874755242,"results":"17","hashOfConfig":"12"},{"size":372,"mtime":1607670512140,"results":"18","hashOfConfig":"12"},{"size":3534,"mtime":1607795070211,"results":"19","hashOfConfig":"12"},{"size":516,"mtime":1607795478888,"results":"20","hashOfConfig":"12"},{"size":7570,"mtime":1607891896684,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1p0ubig",{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"32","messages":"33","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"24"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"D:\\Code\\Projects\\maze-algorithms\\src\\index.js",[],["45","46"],"D:\\Code\\Projects\\maze-algorithms\\src\\App.js",["47"],"import logo from './logo.svg';\nimport './App.css';\nimport AppCanvas from './components/AppCanvas';\nimport { createContext, useEffect, useReducer, useRef, useState } from 'react';\nimport Controls from './components/Controls';\n\nfunction appStateReducer(state, action){\n\tswitch(action.type){\n\t\tcase \"UpdateMaze\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tmaze: action.payload\n\t\t\t}\n\t\tcase \"UpdateGrid\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tgrid: action.payload.grid,  \n\t\t\t\torigin: action.payload.origin\n\t\t\t}\n\t\tcase \"ResizeCanvas\":\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcanvasSize: action.payload\n\t\t\t}\n\t\tdefault:\n\t\t\tconsole.error(`Unknown AppState action type ${action.type}`);\t\n\t\t\treturn state;\n\t}\n}\n\nexport const AppStateContext = createContext();\n\nfunction App() {\n\n\tconst [appState, dispatch] = useReducer(appStateReducer, {})\n\tconst [frameSize, setFrameSize] = useState({ height: 0, width: 0})\n\tconst [canvasSize, setCanvasSize] = useState(0);\n\tconst appFrameRef = useRef();\n\n\tconst windowResizeHandler = () => {\n\t\tsetFrameSize({\n\t\t\theight: appFrameRef.current.getBoundingClientRect().height,\n\t\t\twidth: appFrameRef.current.getBoundingClientRect().width\n\t\t});\n\t}\n\n\t// Register window resize handler on load and initialize frameSize\n\tuseEffect(() => {\n\t\twindowResizeHandler();\n\t\tdocument.addEventListener(\"resize\", windowResizeHandler);\n\t}, []);\n\n\t// Update the canvas size to match the frame size\n\tuseEffect(() => {\n\t\tconst newSize = Math.min(frameSize.height, frameSize.width) * 0.9;\n\t\tsetCanvasSize(newSize);\n\t\tdispatch({\n\t\t\ttype: \"ResizeCanvas\",\n\t\t\tpayload: newSize\n\t\t})\n\t}, [frameSize]);\n\n\treturn (\n\t<div className=\"App\" ref={appFrameRef}>\n\t\t<AppStateContext.Provider value={[appState, dispatch]}>\n\t\t\t<Controls canvasSize={canvasSize}/>\n\t\t\t{canvasSize > 0 && <AppCanvas canvasSize={canvasSize} />}\n\t\t</AppStateContext.Provider>\n\t</div>\n\t);\n}\n\nexport default App;\n","D:\\Code\\Projects\\maze-algorithms\\src\\reportWebVitals.js",[],"D:\\Code\\Projects\\maze-algorithms\\src\\components\\AppCanvas\\index.js",["48","49","50","51"],"D:\\Code\\Projects\\maze-algorithms\\src\\components\\Controls\\index.js",["52","53","54","55"],"D:\\Code\\Projects\\maze-algorithms\\src\\utils\\SquareGrid.js",[],"D:\\Code\\Projects\\maze-algorithms\\src\\utils\\GridPoint.js",[],"D:\\Code\\Projects\\maze-algorithms\\src\\utils\\HexGrid.js",["56","57"],"import GridPoint from \"./GridPoint\";\r\n\r\nconst sqrt3 = Math.sqrt(3); \r\nconst sqrt1_3 = 1 / Math.sqrt(3);\r\n\r\nexport default class HexGrid{\r\n\tconstructor(height, width, sideLength){\r\n\t\tthis.height = height;\r\n\t\tthis.width = width;\r\n\t\tthis.sideLength = sideLength;\r\n\t\r\n\t\t// Start at the center\r\n\t\tthis.points = [[new GridPoint(0,0)]];\r\n\t\tlet open = this.getNextHexagon();\r\n\r\n\t\t// Until there are no more rings which can fit inside the bounds, repeatedly add rings to the grid\r\n\t\twhile(open.length > 0){\r\n\t\t\t// Assign the open points their neighbours\r\n\t\t\tfor(let index = 0; index < open.length; index++){\r\n\t\t\t\tconst point = open[index];\r\n\t\t\t\t\r\n\t\t\t\t// If the point is a corner, connect it to the previous corner\r\n\t\t\t\tif(index % this.points.length === 0){\r\n\t\t\t\t\t// Connect it using index matching for hexagons which don't leave the bounds\r\n\t\t\t\t\tif(open.length === this.points.length * 6){\r\n\t\t\t\t\t\tpoint.addNeighbour(this.points[this.points.length-1][Math.floor(index * (1 - 1 / this.points.length))]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Else connect it to the two side points closest to it\r\n\t\t\t\telse{\r\n\t\t\t\t\tconst sideNumber = Math.floor(index / this.points.length);\r\n\t\t\t\t\tconst sideIndex = index % this.points.length;\r\n\r\n\t\t\t\t\t// Calculate the index using the smaller hexagon and account for index wrapping\r\n\t\t\t\t\tconst nextIndex = (sideNumber * (this.points.length - 1) + sideIndex) % ((this.points.length -1)* 6);\r\n\t\t\t\t\tconst prevIndex = nextIndex - 1 < 0 ? ((this.points.length - 1) * 6 - 1) : nextIndex - 1;\r\n\r\n\t\t\t\t\tpoint.addNeighbour(this.points[this.points.length-1][prevIndex]);\r\n\t\t\t\t\tpoint.addNeighbour(this.points[this.points.length-1][nextIndex]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// connect point to its neighbours\r\n\t\t\t\tconst prevIndex = Math.max(index - 1, 0);\r\n\t\t\t\tconst nextIndex = (index + 1) % open.length;\r\n\t\t\t\tpoint.addNeighbour(open[prevIndex]);\r\n\t\t\t\tpoint.addNeighbour(open[nextIndex]);\r\n\t\t\t}\r\n\r\n\t\t\t// Add the points to the grid and get the next hexagon\r\n\t\t\tthis.points.push(open)\r\n\t\t\topen = this.getNextHexagon();\r\n\t\t}\r\n\t}\r\n\t\t\r\n\t\r\n\t// Get all points which can be reached as a point on a regular hexagon concentric to the current grid\r\n\tgetNextHexagon(){\r\n\t\t// Figure out how far out the ring is\r\n\t\tconst index = this.points.length;\r\n\t\tconst newRing = [];\r\n\r\n\t\t// Iterate over each hexagon vertex and collect #index number of points into the new ring\r\n\t\t// Use discrete angle counting to cirumvent JS rounding errors\r\n\t\tfor(let angleIndex = 0; angleIndex < 6; angleIndex++){\r\n\t\t\tconst angle = angleIndex * Math.PI / 3;\r\n\t\t\tconst nextAngle = ((angleIndex + 1)%6) * Math.PI / 3;\r\n\r\n\t\t\t// Calculate a unit vector between the current hex vertex and the next hex vertex\r\n\t\t\tconst angleLine = {\r\n\t\t\t\tx: Math.cos(nextAngle) - Math.cos(angle),\r\n\t\t\t\ty: Math.sin(nextAngle) - Math.sin(angle)\r\n\t\t\t}\r\n\t\t\tangleLine.x /= Math.hypot(angleLine.x, angleLine.y);\r\n\t\t\tangleLine.y /= Math.hypot(angleLine.x, angleLine.y);\r\n\r\n\t\t\t// Add index number of points along the unit vector\r\n\t\t\tfor(let sideNumber = 0; sideNumber < index; sideNumber++){\r\n\t\t\t\tconst p = {\r\n\t\t\t\t\tx: this.sideLength * index * Math.cos(angle) + angleLine.x * sideNumber * this.sideLength,\r\n\t\t\t\t\ty: this.sideLength * index * Math.sin(angle) + angleLine.y * sideNumber * this.sideLength\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Only add the point if it fits in the bounds\r\n\t\t\t\tif(0 > Math.abs(p.x) \r\n\t\t\t    || Math.abs(p.x) > this.width / 2\r\n\t\t\t\t|| 0 > Math.abs(p.y)\r\n\t\t\t\t|| Math.abs(p.y) > this.height / 2){\r\n\t\t\t\t\treturn [];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tnewRing.push(new GridPoint(p.x, p.y));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newRing;\r\n\t}\r\n}","D:\\Code\\Projects\\maze-algorithms\\src\\components\\Controls\\Slider.js",["58"],"D:\\Code\\Projects\\maze-algorithms\\src\\utils\\MazeGenerator.js",["59","60","61","62","63","64","65"],{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","severity":1,"message":"71","line":1,"column":8,"nodeType":"72","messageId":"73","endLine":1,"endColumn":12},{"ruleId":"70","severity":1,"message":"74","line":17,"column":23,"nodeType":"72","messageId":"73","endLine":17,"endColumn":37},{"ruleId":"70","severity":1,"message":"75","line":61,"column":13,"nodeType":"72","messageId":"73","endLine":61,"endColumn":17},{"ruleId":"76","severity":1,"message":"77","line":166,"column":5,"nodeType":"78","endLine":166,"endColumn":62,"suggestions":"79"},{"ruleId":"76","severity":1,"message":"80","line":172,"column":5,"nodeType":"78","endLine":172,"endColumn":7,"suggestions":"81"},{"ruleId":"70","severity":1,"message":"82","line":1,"column":47,"nodeType":"72","messageId":"73","endLine":1,"endColumn":56},{"ruleId":"70","severity":1,"message":"83","line":82,"column":20,"nodeType":"72","messageId":"73","endLine":82,"endColumn":32},{"ruleId":"70","severity":1,"message":"84","line":86,"column":21,"nodeType":"72","messageId":"73","endLine":86,"endColumn":34},{"ruleId":"70","severity":1,"message":"85","line":87,"column":21,"nodeType":"72","messageId":"73","endLine":87,"endColumn":34},{"ruleId":"70","severity":1,"message":"86","line":3,"column":7,"nodeType":"72","messageId":"73","endLine":3,"endColumn":12},{"ruleId":"70","severity":1,"message":"87","line":4,"column":7,"nodeType":"72","messageId":"73","endLine":4,"endColumn":14},{"ruleId":"76","severity":1,"message":"88","line":14,"column":5,"nodeType":"78","endLine":14,"endColumn":12,"suggestions":"89"},{"ruleId":"70","severity":1,"message":"90","line":1,"column":8,"nodeType":"72","messageId":"73","endLine":1,"endColumn":17},{"ruleId":"70","severity":1,"message":"91","line":2,"column":8,"nodeType":"72","messageId":"73","endLine":2,"endColumn":15},{"ruleId":"70","severity":1,"message":"92","line":3,"column":8,"nodeType":"72","messageId":"73","endLine":3,"endColumn":18},{"ruleId":"93","severity":1,"message":"94","line":85,"column":41,"nodeType":"95","messageId":"96","endLine":85,"endColumn":115},{"ruleId":"70","severity":1,"message":"97","line":102,"column":14,"nodeType":"72","messageId":"73","endLine":102,"endColumn":15},{"ruleId":"93","severity":1,"message":"98","line":128,"column":42,"nodeType":"95","messageId":"96","endLine":128,"endColumn":127},{"ruleId":"70","severity":1,"message":"99","line":190,"column":10,"nodeType":"72","messageId":"73","endLine":190,"endColumn":26},"no-native-reassign",["100"],"no-negated-in-lhs",["101"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'dispatchConfig' is assigned a value but never used.","'diff' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'drawGrid' and 'drawOutline'. Either include them or remove the dependency array.","ArrayExpression",["102"],"React Hook useEffect has a missing dependency: 'sketch'. Either include it or remove the dependency array.",["103"],"'useEffect' is defined but never used.","'setMazeStart' is assigned a value but never used.","'setGridConfig' is assigned a value but never used.","'setMazeConfig' is assigned a value but never used.","'sqrt3' is assigned a value but never used.","'sqrt1_3' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'props.output'. Either include it or remove the dependency array.",["104"],"'GridPoint' is defined but never used.","'HexGrid' is defined but never used.","'SquareGrid' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'largestIndex', 'largestIndex'.","ArrowFunctionExpression","unsafeRefs","'_' is assigned a value but never used.","Function declared in a loop contains unsafe references to variable(s) 'largestFragIndex', 'largestFragIndex'.","'generateRingMaze' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"105","fix":"106"},{"desc":"107","fix":"108"},{"desc":"109","fix":"110"},"Update the dependencies array to be: [appState.maze, appState.origin, appState.grid, renderer, drawGrid, drawOutline]",{"range":"111","text":"112"},"Update the dependencies array to be: [sketch]",{"range":"113","text":"114"},"Update the dependencies array to be: [props.output, value]",{"range":"115","text":"116"},[4426,4483],"[appState.maze, appState.origin, appState.grid, renderer, drawGrid, drawOutline]",[4628,4630],"[sketch]",[257,264],"[props.output, value]"]